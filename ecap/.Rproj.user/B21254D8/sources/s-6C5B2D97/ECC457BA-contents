## NEW ESPN Adjustment Plot Script
## Packages and Libraries
require(lubridate)
require(tidyverse)
require(tidyr)
require(progress)
require(splines)
require(quadprog)
require(ggplot2)
library(tikzDevice)
library(parallel)

## Load the ESPN
filedir <- "~/Documents/Research Projects/Irrational Exuberance/ESPN Application/Football/Python Web Scraping/ESPN Football Data" 
x <- read_csv(file.path(filedir, "College Football Prediction Data years 16-18 rem_duplic.csv"))
x <- x[x$year < 2018, ]

## Clean the data
play_clock_dt <- ms(gsub(":([^:]*)$", "", x$play.clock.displayValue))
play_clock_dt_sec <- minute(play_clock_dt)*60 + second(play_clock_dt)
x$play_clock_dt_sec <- play_clock_dt_sec

## Function to get the closest probabiltiies from the data for a given time point and quarter
getProbTime <- function(quarter, time, dta) {
  ## Convert inputed time into a date time object
  time_temp <- ms(time)
  time_sec <- minute(time_temp)*60 + second(time_temp)
  
  ## Subset the data on that quarter
  ## Subset on second period and sort by the time
  dta_sort <- dta %>% 
    filter(play.period.number == quarter) %>%
    arrange(play.clock.displayValue)
  target_time <- dta_sort$play_clock_dt_sec[which.min(abs(time_sec-dta_sort$play_clock_dt_sec))]
  
  p_tilde_all <- sapply(unique(dta_sort$game_id), function(g) {
    subset_dta <- dta_sort %>%
      filter(game_id == g) %>%
      select(play_clock_dt_sec, homeWinPercentage, home_win)
    
    target_time <- subset_dta$play_clock_dt_sec[which.min(abs(time_sec-subset_dta$play_clock_dt_sec))]
    
    ## Subset on the target time
    p.tilde.win <- subset_dta[subset_dta$play_clock_dt_sec == target_time,]
    
    p.tilde <- p.tilde.win$homeWinPercentage[1]
    home_win <- p.tilde.win$home_win[1]
    
    return(c(p.tilde, home_win))
  })
  p_tilde_all <- t(p_tilde_all)
  p_tilde_all <- as.data.frame(p_tilde_all)
  p_tilde_all[,1] <- as.numeric(as.character(p_tilde_all[,1]))
  colnames(p_tilde_all) <- c("p.tilde", "home_win")
  
  return(p_tilde_all)
}

## loop over time stamps and quarters
## Time is of the form "minutes:seconds"3
time_seq <- c("01:00", "00:50", "00:40", "00:30", "00:20", "00:10")
quarter_seq <- 4 ## Note that some games have more than 4 quarters

#### Preload containers ####
obs_dta_naive <- matrix(nrow = length(time_seq), ncol = length(quarter_seq))
colnames(obs_dta_naive) <- quarter_seq
rownames(obs_dta_naive) <- time_seq

obs_dta_tweedie <- matrix(nrow = length(time_seq), ncol = length(quarter_seq))
colnames(obs_dta_tweedie) <- quarter_seq
rownames(obs_dta_tweedie) <- time_seq

conf_int_low_naive <- matrix(nrow = length(time_seq), ncol = length(quarter_seq))
colnames(conf_int_low_naive) <- quarter_seq
rownames(conf_int_low_naive) <- time_seq

conf_int_high_naive <- matrix(nrow = length(time_seq), ncol = length(quarter_seq))
colnames(conf_int_high_naive) <- quarter_seq
rownames(conf_int_high_naive) <- time_seq

conf_int_low_tweedie <- matrix(nrow = length(time_seq), ncol = length(quarter_seq))
colnames(conf_int_low_tweedie) <- quarter_seq
rownames(conf_int_low_tweedie) <- time_seq

conf_int_high_tweedie <- matrix(nrow = length(time_seq), ncol = length(quarter_seq))
colnames(conf_int_high_tweedie) <- quarter_seq
rownames(conf_int_high_tweedie) <- time_seq

boot_reps_storage <- list()

## Subset only on 2016 data
x16 <- x[x$year < 2017, ]
x17 <- x[x$year == 2017, ]
# x16 <- x

probs_list_16 <- list()
probs_list_17 <- list()
for (iiii in 1:length(time_seq)) {
  probs_list_16[[iiii]] <- as.data.frame(getProbTime(quarter_seq[1], time_seq[iiii], x16))
  probs_list_17[[iiii]] <- as.data.frame(getProbTime(quarter_seq[1], time_seq[iiii], x17))
}

cl <- makeCluster(8)
clusterExport(cl=cl, list("sample_n", "x16", "x17", "getProbTime", "ms", "time_seq", "minute",
                          "second", "gen_empirical", "avg_violation", "tweedie_adj", "js_grid_fcn",
                          "JS_sigma", "assign_train", "tweedie_est", "pFlip", "mle_binomial", "eta_min_fcn",
                          "tweed.adj.fcn", "risk_cvsplit_fcn", "myns", "const_grid", "theta_grid", "lambda_grid",
                          "gamma_grid", "quarter_seq", "splineDesign", "solve.QP", "probs_list_16", "probs_list_17"))
set.seed(030620)
for (ii in 1:length(time_seq)) {
  for (jj in 1:length(quarter_seq)) {
    clusterExport(cl=cl, list("ii", "jj"))
    boot_reps <- parSapply(cl, 1:200, function(dummy_boot_iter) {
      x16_p <- probs_list_16[[ii]]
      x17_p <- probs_list_17[[ii]]
      x_p <- rbind.data.frame(x16_p, x17_p)
      
      ## Get the probabilities from the ESPN data for a current time point
      p.obs <- x16_p
      p.obs2 <- x17_p
      
      
      adj_ci <- gen_empirical(p.tilde=p.obs$p.tilde, p.tilde2=p.obs2$p.tilde, 
                              0, 0.05, 0.95, 1, win_var=p.obs$home_win, 
                              win_var2=p.obs2$home_win, win_id=1, bias_indicator=F)
      
      return(c(adj_ci$obs_dta_naive, adj_ci$obs_dta_tweedie, adj_ci$obs_dta_naive_ci, adj_ci$obs_dta_tweedie_ci,
               adj_ci$naive_pbar, adj_ci$naive_C, adj_ci$n_delta))
    })
    
    boot_reps_storage[[ii]] <- boot_reps
    
    obs_dta_naive[ii,jj] <- mean(boot_reps[1,])
    obs_dta_tweedie[ii,jj] <- mean(boot_reps[2,])
    
    ## Theoretical Calculation for CI
    p_bar <- mean(boot_reps[5,])
    p_bar_delta <- mean(boot_reps[6,])
    n_delta <- mean(boot_reps[7,])
    se <- sqrt((p_bar*(1-p_bar)) / (n_delta*(p_bar_delta)^2))
    
    ## Conf Int
    #conf_int_low_naive[ii,jj] <- mean(boot_reps[1,]) - qnorm(0.95)*se
    #conf_int_high_naive[ii,jj] <- mean(boot_reps[1,]) + qnorm(0.95)*se
    conf_int_low_naive[ii,jj] <- quantile(boot_reps[3,], c(0.025))
    conf_int_high_naive[ii,jj] <- quantile(boot_reps[3,], c(0.975))
    conf_int_low_tweedie[ii,jj] <- quantile(boot_reps[4,], c(0.025))
    conf_int_high_tweedie[ii,jj] <- quantile(boot_reps[4,], c(0.975))
    
  }  
}
stopCluster(cl)

boot_reps_storage_05 <- boot_reps_storage 
saveRDS(boot_reps_storage_05, file = "boot_reps_storage_05.rds")

###############
## Make Plot ##
###############

plt_vec_naive <- as.vector(obs_dta_naive)
plt_vec_tweedie <- as.vector(obs_dta_tweedie)

## Convert the time
time_convert_const <- vector()
time_add <- 15*(4-quarter_seq)
jj <- 1
for (qq in quarter_seq) {
  time_convert_const <- c(time_convert_const, rep(time_add[jj], length(time_seq)))
  jj <- jj + 1
}

time_left_orig <- as.numeric(rep(gsub(":",".", time_seq), length(quarter_seq))) + time_convert_const
temp_time <- strsplit(as.character(time_left_orig), "\\.")
time_left <- unlist(lapply(temp_time, function(i) {
  if(length(i) > 1) {
    dec <- i[2]
    ifelse(length(dec) < 2, dec <- paste(dec,0,sep = ""), dec <- dec)
    dec_conv <- unlist(strsplit(as.character(as.numeric(dec)/60), "\\."))[2]
  }
  else {
    dec_conv <- 0
  }
  new_time <- as.numeric(paste(i[1], dec_conv, sep = "."))
  return(new_time)
}))       

## Add the naive line info w/ CI
conf_int_low_naive_save <- conf_int_low_naive
expected_line <- cbind.data.frame(time_order=1:length(plt_vec_naive), 
                                  avg_naive=plt_vec_naive, avg_tweedie=plt_vec_tweedie)
conf_int_low_naive <- sapply(conf_int_low_naive, function(p) {
  if(p<=-1) {
    p <- p+rnorm(1, mean=-2, sd=0.0001)
  }
  return(p)
})
expected_line$conf_up_naive <- as.vector(conf_int_high_naive)
expected_line$conf_low_naive <- as.vector(conf_int_low_naive)

## Add the tweedie line info w/ CI
conf_int_low_tweedie_save <- conf_int_low_tweedie
expected_line$conf_up_tweedie <- as.vector(conf_int_high_tweedie)
expected_line$conf_low_tweedie <- as.vector(conf_int_low_tweedie)

expected_line$time_left <- time_left
expected_line$time_left_orig <- time_left_orig
## Add the reverse of time left to make sense for the plot
expected_line$rev_time_left <- 60-expected_line$time_left

## Change expected_line to long instead of wide
expected_line_long <- expected_line %>%
  gather(v, value, conf_up_naive:conf_low_tweedie) %>%
  select(-one_of(c("time_order"))) %>%
  separate(v, c("conf", "type"), sep = "conf_", extra = "merge") %>%
  drop_na() %>%
  spread(conf, type) %>%
  rename(type = V1) %>%
  separate(type, into = c("conf","type"),sep = "_")%>%
  # bring upper and lower back into one row
  spread(conf,value) %>%
  # now we do the same with the avg values
  gather(v,value, avg_naive:avg_tweedie) %>%
  rename(adj_type=v) %>%
  mutate(adj_type = substr(adj_type,5,nchar(adj_type))) %>%
  filter(type == adj_type)
# expected_line_longrename(expected_line_long, "Adjustment Type" = adj_type)
## Grid for the plot object
expected_line_long$low[expected_line_long$low <=-1] <- -1
## Change levels for type
expected_line_long$adj_type[expected_line_long$adj_type=="naive"] <- "ESPN Unadjusted"
expected_line_long$adj_type[expected_line_long$adj_type=="tweedie"] <- "ECAP"

plt <- ggplot(expected_line_long, aes(x=time_left, 
                                      group=adj_type, colour=adj_type)) +
  geom_line(size=1.5, aes(y=value)) +
  scale_x_reverse(breaks=time_left, labels=time_seq) +
  geom_line(aes(y=low), linetype="longdash", alpha=0.9, size=0.4) +
  geom_line(aes(y=up), linetype="longdash", alpha=0.9, size=0.4) +
  xlab("Seconds left in game") +
  ylab("$\\widehat{EC_\\delta}$") + 
  theme_classic(base_size = 10) +
  labs(color = "Method Type") +
  theme(legend.position=c(0.2, 0.89), legend.title = element_text(size = 9), legend.text = element_text(size = 9), 
        axis.title.x = element_text(size=8), axis.title.y = element_text(size=8)) +
  scale_color_manual(values=c("#009E73","#D55E00")) +
  geom_hline(yintercept=0, linetype="dotted", size=0.8,
             color = "black", alpha=0.82)

## Tikz code
tikz(file = "ESPN_Plot_BootCI_inbucket.tex", width = 5.5, height = 2.8)
plt
dev.off()

